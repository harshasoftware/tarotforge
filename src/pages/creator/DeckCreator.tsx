import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { useNavigate, useLocation } from 'react-router-dom';
import { Wand2, Sparkles, Save, ArrowRight, AlertCircle, Check, Crown, TrendingUp } from 'lucide-react';
import { useAuth } from '../../context/AuthContext';
import { useSubscription } from '../../context/SubscriptionContext';
import { useDeckLimits } from '../../context/DeckLimitContext';
import CardGallery from '../../components/creator/CardGallery';
import { checkDeckGenerationLimit, recordDeckGeneration } from '../../lib/deck-usage';
import { generateCardDescription, generateCardImage, generateThemeSuggestions, generateElaborateTheme } from '../../lib/gemini-ai';
import { supabase } from '../../lib/supabase';
import { v4 as uuidv4 } from 'uuid';
import { Card } from '../../types';
import TarotLogo from '../../components/ui/TarotLogo';

// Major Arcana card names
const majorArcanaCards = [
  'The Fool', 'The Magician', 'The High Priestess', 'The Empress', 'The Emperor',
  'The Hierophant', 'The Lovers', 'The Chariot', 'Strength', 'The Hermit',
  'Wheel of Fortune', 'Justice', 'The Hanged Man', 'Death', 'Temperance',
  'The Devil', 'The Tower', 'The Star', 'The Moon', 'The Sun',
  'Judgement', 'The World'
];

// Minor Arcana suits and values
const minorArcanaSuits = ['Wands', 'Cups', 'Swords', 'Pentacles'];
const minorArcanaValues = [
  'Ace', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten',
  'Page', 'Knight', 'Queen', 'King'
];

const DeckCreator: React.FC = () => {
  const { user } = useAuth();
  const { isSubscribed } = useSubscription();
  const location = useLocation();
  const { canGenerateMajorArcana, canGenerateCompleteDeck, refreshLimits } = useDeckLimits();
  const navigate = useNavigate();
  
  // Deck creation state
  const [deckId, setDeckId] = useState<string>('');
  const [deckTitle, setDeckTitle] = useState('');
  const [deckDescription, setDeckDescription] = useState('');
  const [deckTheme, setDeckTheme] = useState('');
  const [deckStyle, setDeckStyle] = useState('');
  const [imageQuality, setImageQuality] = useState<'medium' | 'high'>('medium');
  const [themeSuggestions, setThemeSuggestions] = useState<string[]>([]);
  
  // Card generation state
  const [generatingCard, setGeneratingCard] = useState(false);
  const [currentCardIndex, setCurrentCardIndex] = useState(0);
  const [generatedCards, setGeneratedCards] = useState<Card[]>([]);
  const [regeneratingCardId, setRegeneratingCardId] = useState<string | null>(null);
  const [cardPrompt, setCardPrompt] = useState('');
  const [generationProgress, setGenerationProgress] = useState(0);
  const [generationStage, setGenerationStage] = useState<'description' | 'image'>('description');
  
  // Saving state
  const [isSaving, setIsSaving] = useState(false);
  const [saveSuccess, setSaveSuccess] = useState(false);
  const [saveError, setError] = useState<string | null>(null);
  
  // Upgrade modal state
  const [showUpgradeModal, setShowUpgradeModal] = useState(false);
  
  // Initialize deck creation on mount
  const [limitCheckResult, setLimitCheckResult] = useState<any>(null);
  
  useEffect(() => {
    // Generate a new deck ID
    const newDeckId = uuidv4();
    setDeckId(newDeckId);
    
    // Check if we have state passed from navigation
    const state = location.state as any;
    if (state) {
      // Auto-generate deck details from the theme
      if (state.initialTheme) {
        autoGenerateDeckDetails(state.initialTheme);
      }
      
      // If startGenerating is true, automatically start card generation after a short delay
      if (state.startGenerating) {
        setTimeout(() => {
          startCardGeneration(newDeckId);
        }, 1000);
      }
      
    }
  }, [location]);
  
  // Load theme suggestions on mount
  useEffect(() => {
    const loadThemeSuggestions = async () => {
      try {
        const suggestions = await generateThemeSuggestions(8);
        setThemeSuggestions(suggestions);
      } catch (error) {
        console.error('Error loading theme suggestions:', error);
      }
    };
    
    loadThemeSuggestions();
  }, []);
  
  // Auto-generate deck details from a theme prompt
  const autoGenerateDeckDetails = async (themePrompt: string) => {
    try {
      // Extract theme and style from the prompt
      const parts = themePrompt.split(':');
      let theme = '';
      let description = '';
      
      if (parts.length > 1) {
        // If the prompt is in format "Theme: Description"
        theme = parts[0].trim();
        description = parts.slice(1).join(':').trim();
      } else {
        // If it's just a theme, generate a description
        theme = themePrompt.trim();
        description = await generateElaborateTheme(theme);
      }
      
      // Generate a title based on the theme
      const title = `${theme.charAt(0).toUpperCase() + theme.slice(1)} Tarot`;
      
      // Set random art style if not provided
      const styles = ['Watercolor', 'Digital Art', 'Art Nouveau', 'Minimalist', 'Oil Painting', 'Surrealist', 'Photorealistic', 'Anime'];
      const randomStyle = styles[Math.floor(Math.random() * styles.length)];
      
      // Update state with generated details
      setDeckTitle(title);
      setDeckDescription(description);
      setDeckTheme(theme);
      setDeckStyle(randomStyle);
      
      // Set card prompt based on description
      setCardPrompt(description);
    } catch (error) {
      console.error('Error auto-generating deck details:', error);
    }
  };
  
  // Start card generation process
  const startCardGeneration = async (deckIdToUse = deckId) => {
    if (!deckTitle || !deckTheme || !deckStyle) {
      // If fields are missing, generate them automatically
      if (!deckTitle) setDeckTitle(`${deckTheme || 'Mystical'} Tarot`);
      if (!deckTheme) setDeckTheme('Mystical');
      if (!deckStyle) setDeckStyle('Digital Art');
    }

    // Determine deck type based on eligibility
    const deckType = isSubscribed || canGenerateCompleteDeck ? 'complete' : 'major_arcana';
    
    // Check if user has reached their generation limit
    const limitCheck = await checkDeckGenerationLimit(user?.id, deckType);
    setLimitCheckResult(limitCheck);
    
    if (!limitCheck.canGenerate) {
      // Set error message based on the reason
      if (limitCheck.reason === 'limit_reached') {
        setError(`You've reached your ${deckType === 'major_arcana' ? 'Major Arcana' : 'Complete Deck'} generation limit for this billing period.`);
      } else {
        setError('You cannot generate more decks at this time.');
      }
      
      // Show upgrade modal
      setShowUpgradeModal(true);
      
      // Return early to prevent further execution
      return;
    }
    
    try {
      // Create or update the deck in the database
      const { data: deck, error: deckError } = await supabase
        .from('decks')
        .insert([{
          creator_id: user?.id,
          title: deckTitle,
          description: deckDescription || `A ${deckTheme} themed tarot deck with ${deckStyle} style.`,
          theme: deckTheme,
          style: deckStyle,
          card_count: isSubscribed || canGenerateCompleteDeck ? 78 : 22,
          price: 0,
          is_free: true,
          is_public: true,
          is_listed: false,
          is_sellable: false,
          cover_image: 'https://images.pexels.com/photos/6044266/pexels-photo-6044266.jpeg', // Placeholder
          sample_images: []
        }])
        .select()
        .single();
        
      if (deckError) {
        throw deckError;
      }
      
      // Update the deck ID if needed
      const finalDeckId = deck.id;
      setDeckId(finalDeckId);
      
      // Record the deck generation
      await recordDeckGeneration(user?.id || '', deckType);
      
      // Refresh limits to update UI
      refreshLimits();
      
      // Start generating the first card
      generateNextCard(finalDeckId, 0);
    } catch (error) {
      console.error('Error creating deck:', error);
      setError('Failed to create deck. Please try again.');
    }
  };
  
  // Generate the next card in sequence
  const generateNextCard = async (deckId: string, index: number) => {
    // Determine if we're generating Major or Minor Arcana
    const isMajorArcana = index < majorArcanaCards.length; 
    
    // Check if we should stop at Major Arcana (22 cards) for free users
    if (index >= majorArcanaCards.length && !(isSubscribed || canGenerateCompleteDeck)) {
      setError('You need to upgrade to generate Minor Arcana cards.');
      setShowUpgradeModal(true);
      return;
    }
    
    // Get the card name
    let cardName = '';
    if (isMajorArcana) {
      cardName = majorArcanaCards[index];
    } else {
      const suitIndex = Math.floor((index - majorArcanaCards.length) / minorArcanaValues.length);
      const valueIndex = (index - majorArcanaCards.length) % minorArcanaValues.length;
      cardName = `${minorArcanaValues[valueIndex]} of ${minorArcanaSuits[suitIndex]}`;
    }
    
    setGeneratingCard(true);
    setCurrentCardIndex(index);
    setGenerationStage('description');
    setGenerationProgress(0);
    
    try {
      // Generate card description
      const description = await generateCardDescription(cardName, index);
      
      // Generate card image
      const imageUrl = await generateCardImage(cardName, description);
      
      // Create a new card object
      const newCard: Card = {
        id: uuidv4(),
        deck_id: deckId,
        name: cardName,
        description,
        image_url: imageUrl,
        card_type: isMajorArcana ? 'major' : 'minor',
        suit: isMajorArcana ? undefined : minorArcanaSuits[Math.floor((index - majorArcanaCards.length) / minorArcanaValues.length)].toLowerCase() as any,
        keywords: extractKeywords(description),
        order: index
      };
      
      // Add the card to the generated cards array
      setGeneratedCards(prev => [...prev, newCard]);
      
      // Save the card to the database
      const { error: cardError } = await supabase
        .from('cards')
        .insert([{
          id: newCard.id,
          deck_id: deckId,
          name: newCard.name,
          description: newCard.description,
          image_url: newCard.image_url,
          card_type: newCard.card_type,
          suit: newCard.suit,
          keywords: newCard.keywords,
          order: newCard.order
        }]);
        
      if (cardError) {
        console.error('Error saving card:', cardError);
      }
      
      // If this is the first card, update the deck cover image
      if (index === 0) {
        const { error: updateError } = await supabase
          .from('decks')
          .update({
            cover_image: newCard.image_url,
            sample_images: [newCard.image_url]
          })
          .eq('id', deckId);
          
        if (updateError) {
          console.error('Error updating deck cover:', updateError);
        }
      }
      
      // Move to the next card or finish
      setGeneratingCard(false);
      
      // Determine if we should continue generating cards
      const cardLimit = isSubscribed || canGenerateCompleteDeck ? 78 : 22;
      if (index + 1 < cardLimit) {
        // Generate the next card after a short delay
        setTimeout(() => {
          generateNextCard(deckId, index + 1);
        }, 500);
      }
    } catch (error) {
      console.error('Error generating card:', error);
      setGeneratingCard(false);
      setError('Failed to generate card. Please try again.');
    }
  };
  
  // Generate card description
  const generateCardDescription = async (cardName: string, cardIndex: number): Promise<string> => {
    try {
      // Update progress for description generation
      const updateDescriptionProgress = (progress: number) => {
        setGenerationProgress(progress / 2); // Description is first half of progress
      };
      
      // Generate the description
      const description = await generateCardDescription({
        cardName,
        deckTheme: deckTheme,
        onProgress: updateDescriptionProgress
      });
      
      setGenerationStage('image');
      setGenerationProgress(50); // Start image generation at 50%
      
      return description;
    } catch (error) {
      console.error('Error generating description:', error);
      return `The ${cardName} represents a powerful symbol in tarot. In the context of ${deckTheme}, it connects to themes of transformation and insight.`;
    }
  };
  
  // Generate card image
  const generateCardImage = async (cardName: string, description: string): Promise<string> => {
    try {
      // Update progress for image generation
      const updateImageProgress = (progress: number, stage: 'generating' | 'uploading') => {
        // Image is second half of progress (50-100%)
        const baseProgress = 50;
        const adjustedProgress = baseProgress + (progress / 2);
        setGenerationProgress(adjustedProgress);
      };
      
      // Generate the image
      const imageUrl = await generateCardImage({
        cardName,
        theme: deckTheme,
        style: deckStyle,
        description,
        additionalPrompt: cardPrompt,
        deckId,
        onProgress: updateImageProgress
      });
      
      return imageUrl;
    } catch (error) {
      console.error('Error generating image:', error);
      // Return a placeholder image
      return `https://placehold.co/600x900?text=${encodeURIComponent(cardName)}`;
    }
  };
  
  // Extract keywords from description
  const extractKeywords = (description: string): string[] => {
    // Simple keyword extraction - split by commas and periods, then clean up
    const words = description.split(/[,.;]/).map(word => word.trim());
    const keywords = words
      .filter(word => word.length > 3 && word.length < 20)
      .slice(0, 5);
    
    return keywords;
  };
  
  // Regenerate a specific card
  const handleRegenerateCard = async (cardId: string) => {
    // Find the card to regenerate
    const cardToRegenerate = generatedCards.find(card => card.id === cardId);
    if (!cardToRegenerate) return;
    
    setRegeneratingCardId(cardId);
    setGenerationStage('description');
    setGenerationProgress(0);
    
    try {
      // Generate new description
      const description = await generateCardDescription(cardToRegenerate.name, cardToRegenerate.order);
      
      // Generate new image
      const imageUrl = await generateCardImage(cardToRegenerate.name, description);
      
      // Update the card
      const updatedCard = {
        ...cardToRegenerate,
        description,
        image_url: imageUrl,
        keywords: extractKeywords(description)
      };
      
      // Update the generated cards array
      setGeneratedCards(prev => 
        prev.map(card => card.id === cardId ? updatedCard : card)
      );
      
      // Update the card in the database
      const { error: updateError } = await supabase
        .from('cards')
        .update({
          description: updatedCard.description,
          image_url: updatedCard.image_url,
          keywords: updatedCard.keywords
        })
        .eq('id', cardId);
        
      if (updateError) {
        console.error('Error updating card:', updateError);
      }
      
      // If this is the first card, update the deck cover image
      if (cardToRegenerate.order === 0) {
        const { error: deckUpdateError } = await supabase
          .from('decks')
          .update({
            cover_image: updatedCard.image_url,
            sample_images: [updatedCard.image_url]
          })
          .eq('id', deckId);
          
        if (deckUpdateError) {
          console.error('Error updating deck cover:', deckUpdateError);
        }
      }
    } catch (error) {
      console.error('Error regenerating card:', error);
      setError('Failed to regenerate card. Please try again.');
    } finally {
      setRegeneratingCardId(null);
    }
  };
  
  // Save the deck
  const saveDeck = async () => {
    if (!deckId) return;
    
    setIsSaving(true);
    setError(null);
    
    try {
      // Update the deck in the database
      const { error: updateError } = await supabase
        .from('decks')
        .update({
          title: deckTitle,
          description: deckDescription,
          theme: deckTheme,
          style: deckStyle,
          is_listed: true, // Make it visible in the marketplace
          updated_at: new Date().toISOString()
        })
        .eq('id', deckId);
        
      if (updateError) {
        throw updateError;
      }
      
      setSaveSuccess(true);
      
      // Navigate to the deck details page after a delay
      setTimeout(() => {
        navigate(`/marketplace/${deckId}`);
      }, 2000);
    } catch (error) {
      console.error('Error saving deck:', error);
      setError('Failed to save deck. Please try again.');
    } finally {
      setIsSaving(false);
    }
  };
  
  return (
    <div className="min-h-screen pt-12 pb-20">
      <div className="container mx-auto px-4">
        <div className="max-w-6xl mx-auto">
          <h1 className="text-3xl font-serif font-bold mb-6 mt-8">Create Your Tarot Deck</h1>
          
          {/* Error message */}
          {saveError && (
            <div className="mb-6 p-4 border border-destructive/30 bg-destructive/10 rounded-lg flex items-start gap-3">
              <AlertCircle className="h-5 w-5 text-destructive shrink-0 mt-0.5" />
              <p className="text-sm text-destructive">{saveError}</p>
            </div>
          )}
          
          {/* Card Generation Progress */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
            className="bg-card border border-border rounded-xl p-6 mb-8"
          >
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-xl font-serif font-bold">{deckTitle || "Your Tarot Deck"}</h2>
              <div className="text-sm text-muted-foreground">
                {generatedCards.length} of {isSubscribed || canGenerateCompleteDeck ? 78 : 22} cards generated
              </div>
            </div>
            
            {/* Generation progress bar */}
            {generatingCard && (
              <div className="mb-6">
                <div className="flex justify-between text-sm mb-2">
                  <span>Generating: {majorArcanaCards.includes(generatedCards.length < majorArcanaCards.length ? majorArcanaCards[generatedCards.length] : 'Minor Arcana')}</span>
                  <span className="text-primary">{generationStage === 'description' ? 'Creating description' : 'Creating image'}</span>
                </div>
                <div className="w-full h-2 bg-muted/30 rounded-full overflow-hidden">
                  <div 
                    className="h-full bg-primary rounded-full transition-all duration-300"
                    style={{ width: `${generationProgress}%` }}
                  ></div>
                </div>
              </div>
            )}
            
            {/* Generated cards gallery */}
            {generatedCards.length > 0 ? (
              <CardGallery 
                cards={generatedCards} 
                onRegenerateCard={handleRegenerateCard}
                isRegenerating={!!regeneratingCardId}
                activeCardId={regeneratingCardId}
              />
            ) : !generatingCard && (
              <div className="text-center py-12">
                <Wand2 className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
                <h3 className="text-xl font-medium mb-2">Starting Card Generation</h3>
                <p className="text-muted-foreground mb-6">
                  Your deck is being prepared. Cards will appear here as they're generated.
                </p>
                <button
                  onClick={() => startCardGeneration()}
                  className="btn btn-primary py-2 px-6 inline-flex items-center"
                >
                  <Sparkles className="mr-2 h-5 w-5" />
                  Start Generation
                </button>
              </div>
            )}
            
            {/* Save deck button */}
            {generatedCards.length > 0 && !generatingCard && (
              <div className="mt-6 pt-6 border-t border-border flex justify-between items-center">
                {saveSuccess ? (
                  <div className="flex items-center text-success">
                    <Check className="h-5 w-5 mr-2" />
                    <span>Deck saved successfully! Redirecting...</span>
                  </div>
                ) : saveError ? (
                  <div className="flex items-center text-destructive">
                    <AlertCircle className="h-5 w-5 mr-2" />
                    <span>{saveError}</span>
                  </div>
                ) : (
                  <div className="text-sm text-muted-foreground">
                    {generatedCards.length === (isSubscribed || canGenerateCompleteDeck ? 78 : 22) 
                      ? 'All cards have been generated!' 
                      : 'Cards are being generated automatically...'}
                  </div>
                )}
                
                <button
                  onClick={saveDeck}
                  disabled={isSaving || generatingCard}
                  className="btn btn-primary py-2 px-6 flex items-center"
                >
                  {isSaving ? (
                    <>
                      <span className="h-5 w-5 border-2 border-primary-foreground border-t-transparent rounded-full animate-spin mr-2"></span>
                      Saving...
                    </>
                  ) : (
                    <>
                      <Save className="mr-2 h-5 w-5" />
                      Save Deck
                    </>
                  )}
                </button>
              </div>
            )}
          </motion.div>
        </div>
      </div>
      
      {/* Upgrade Modal */}
      {showUpgradeModal && (
        <div className="fixed inset-0 z-50 bg-black/70 flex items-center justify-center p-4">
          <motion.div 
            className="bg-card rounded-xl overflow-hidden max-w-md w-full"
            initial={{ opacity: 0, scale: 0.9 }}
            animate={{ opacity: 1, scale: 1 }}
            transition={{ duration: 0.3 }}
          >
            <div className="p-6 text-center">
              <div className="w-16 h-16 bg-warning/20 rounded-full flex items-center justify-center mx-auto mb-4">
                <Crown className="h-8 w-8 text-warning" />
              </div>
              <h2 className="text-2xl font-serif font-bold mb-2">
                {limitCheckResult?.reason === 'limit_reached' ? 'Deck Limit Reached' : 'Upgrade to Continue'}
              </h2>
              <p className="text-muted-foreground mb-6">
                {limitCheckResult?.reason === 'limit_reached' && limitCheckResult?.planType === 'free'
                  ? `You've used all ${limitCheckResult.limit} of your ${generatedCards.length === 0 ? 'free deck generations' : 'Major Arcana decks'} this month. Your limit will reset on ${limitCheckResult.nextResetDate ? new Date(limitCheckResult.nextResetDate).toLocaleDateString() : 'the first of next month'}.`
                  : generatedCards.length === 0
                    ? "You've reached your deck generation limit. To create more decks, you'll need to upgrade your plan."
                    : "You've generated all 22 Major Arcana cards. To generate the remaining 56 Minor Arcana cards, you'll need to upgrade to a paid plan."}
              </p>
              
              <div className="space-y-3">
                <a
                  href={`/subscription?plan=explorer-plus&deckId=${deckId}`}
                  className="btn btn-warning w-full py-2 flex items-center justify-center"
                >
                  <TrendingUp className="mr-2 h-5 w-5" />
                  Upgrade This Deck ($5)
                </a>
                
                <a
                  href="/subscription"
                  className="btn btn-primary w-full py-2 flex items-center justify-center"
                >
                  <Crown className="mr-2 h-5 w-5" />
                  View Subscription Plans
                </a>
                
                {generatedCards.length > 0 && (
                  <>
                    <button
                      onClick={() => setShowUpgradeModal(false)}
                      className="btn btn-ghost border border-input w-full py-2"
                    >
                      Continue with Major Arcana Only
                    </button>
                    <p className="text-xs text-muted-foreground text-center mt-2">
                      You can still use and publish your Major Arcana deck with 22 cards.
                    </p>
                  </>
                )}
              </div>
            </div>
          </motion.div>
        </div>
      )}
    </div>
  );
};

export default DeckCreator;